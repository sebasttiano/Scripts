"""О функциях классов, методах экземпляров и параметре self"""


class Person:
    def hello():
        print('Hello')


#  Это функция
print(Person.hello)

p = Person()
# это bound метод
print(p.hello)
# Тут все нормально принтит
Person.hello()
# А тут появляется исключение
# p.hello()

print(type(p.hello)) # класс вызовного объекта - метод
print(type(Person.hello)) # а здесь - функция

# у функции класса и связанных с ней методов экземпляров различаются набор свойств
# при вызове метода, ему всегда передается в качестве первого аргумента экземпляр класса с кем он связан,
# в основе также лежит поиск по пространстам имен
# тут нет функции hello
print(p.__dict__)
# Пайтон находит функцию в пространстве имен класса, но для того, что бы дать доступ к другим свойствам экземпляра
# уникальным для каждого экземпляра, в ту же функцию нужно передать ссылку на сам экземпляр. Т.е. код функции как бы
# общий для всех экземпляров, но лежит в пространстве имен класса.
print(2*'\n')
print(p.hello.__self__, "  Это ссылка на этот экземпляр класса")
print(hex(id(p)))
print(p.hello.__func__, "  Это ссылка на главную функцию класса")
# Метод - это такой класс обертка между экземпляром класса и функцией класса. При вызове метода под капотом происходит
# следующее: Сначала находится связанная функция класса и в нее передается сам экземпляр класса
# и другие аргументы. p.hello.__func__(hello.__self__, *args)
print(2*'\n')


class Person2:
    def hello(instance):
        print(instance, " это и есть объект экземпляра, он передается первым аргументом при вызове метода")

p2 = Person2()
p2.hello()
print(hex(id(p2)))

# По соглашению первый параметр принято называть self, потому что это ссылка на самого себя(экземпляр)
# Таким образом когда создается экземпляр класса, то в функции класса передаются ссылки на сам экземпляр класса и они
# становятся методами экземпляра. Т.е. все это ради обособленности пространств имен.